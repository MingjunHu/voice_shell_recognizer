<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>æ™ºèƒ½è¯­éŸ³è¯†åˆ«</title>
</head>
<body>
  <h2>ğŸ™ï¸ æ­£åœ¨å’Œä½ å¯¹è¯...</h2>
  <p>åªåœ¨ä½ è¯´è¯æ—¶å½•éŸ³ï¼Œè‡ªåŠ¨ä¸Šä¼ åˆ°åå°è¯†åˆ«</p>
  <div id="results" style="margin-top: 20px; border: 1px solid #ccc; padding: 10px; min-height: 100px;"></div>

  <script>
    let audioContext;
    let analyser;
    let mediaRecorder;
    let chunks = [];

    let isRecording = false;
    let silenceStartTime = null;
    let recordStartTime = null;
    let currentAudio = null; // å½“å‰æ’­æ”¾çš„éŸ³é¢‘å¯¹è±¡
    let currentAudioPath = null; // å½“å‰æ’­æ”¾çš„éŸ³é¢‘æ–‡ä»¶è·¯å¾„

    const VOLUME_THRESHOLD = 0.05;
    const MAX_RECORD_TIME = 20000;
    const SILENCE_TIMEOUT = 2000;

    async function startMonitoring() {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioContext = new AudioContext();
      const source = audioContext.createMediaStreamSource(stream);

      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      source.connect(analyser);

      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = e => chunks.push(e.data);

      mediaRecorder.onstop = async () => {
        if (chunks.length === 0) return;
        const blob = new Blob(chunks, { type: 'audio/webm' });
        const formData = new FormData();
        formData.append('file', blob, 'recording.webm');

        console.log("â« ä¸Šä¼ éŸ³é¢‘ä¸­...");
        const res = await fetch('/diyvoice/upload-audio/', {
          method: 'POST',
          body: formData
        });
        const data = await res.json();
        const resultsDiv = document.getElementById('results');
        const newResult = document.createElement('div');
        newResult.textContent = data.text;
        //æ˜¾ç¤ºåœ¨æœ€ä¸‹é¢
        newResult.style.border = "1px solid #ccc";
        newResult.style.padding = "5px";
        newResult.style.marginTop = "5px";
        newResult.style.backgroundColor = "#f9f9f9";
        newResult.style.borderRadius = "5px";
        resultsDiv.appendChild(newResult);
        
        // è°ƒç”¨TTSæ¥å£ç”Ÿæˆå¹¶æ’­æ”¾éŸ³é¢‘
        try {
            const ttsRes = await fetch('/diyvoice/generate-tts/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({text: data.text})
            });
            
            if (ttsRes.ok) {
                const result = await ttsRes.json();
                if (result.status === 'success') {
                    console.log('Audio file path:', result.file_path);
                    // åœæ­¢å½“å‰æ’­æ”¾çš„éŸ³é¢‘(å¦‚æœæœ‰)
                    if (currentAudio) {
                        currentAudio.pause();
                        currentAudio.currentTime = 0;
                    }
                    
                    currentAudio = new Audio(result.file_path);
                    currentAudioPath = result.file_path; // ä¿å­˜å½“å‰æ’­æ”¾æ–‡ä»¶è·¯å¾„
                    
                    currentAudio.oncanplaythrough = () => {
                        console.log('Audio ready to play');
                        currentAudio.play().catch(e => {
                            console.error('Play failed:', e);
                        });
                    };
                    
                    currentAudio.onerror = (e) => {
                        console.error('Audio error:', e);
                    };
                    currentAudio.onended = async () => {
                        console.log('Audio playback finished, deleting file');
                        try {
                            const deleteRes = await fetch('/diyvoice/delete-audio/', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({file_path: result.file_path})
                            });
                            const deleteData = await deleteRes.json();
                            if (deleteData.status === 'success') {
                                console.log('Audio file deleted successfully');
                            } else {
                                console.error('Failed to delete audio file:', deleteData.message);
                            }
                        } catch (e) {
                            console.error('Delete request error:', e);
                        }
                    };
                } else {
                    console.error('TTS generation failed');
                }
            } else {
                console.error('TTS request failed:', ttsRes.status);
            }
        } catch (e) {
            console.error('TTS request error:', e);
        }
        
        chunks = [];
      };

      setInterval(monitorVolume, 200);
    }

    function getVolume() {
      const dataArray = new Uint8Array(analyser.fftSize);
      analyser.getByteTimeDomainData(dataArray);
      let sumSquares = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const value = (dataArray[i] - 128) / 128;
        sumSquares += value * value;
      }
      return Math.sqrt(sumSquares / dataArray.length);
    }

    function monitorVolume() {
      const volume = getVolume();

      if (volume > VOLUME_THRESHOLD) {
        // å¦‚æœæ­£åœ¨æ’­æ”¾éŸ³é¢‘ä¸”æ£€æµ‹åˆ°ç”¨æˆ·å£°éŸ³ï¼Œåœæ­¢æ’­æ”¾
        if (currentAudio) {
          console.log("ğŸ¤ æ£€æµ‹åˆ°ç”¨æˆ·å£°éŸ³ï¼Œåœæ­¢å½“å‰æ’­æ”¾");
          const fileToDelete = currentAudioPath;
          currentAudio.pause();
          currentAudio.currentTime = 0; // é‡ç½®æ’­æ”¾ä½ç½®
          currentAudio = null;
          currentAudioPath = null;
          
          // åˆ é™¤è¢«ä¸­æ–­çš„éŸ³é¢‘æ–‡ä»¶
          if (fileToDelete) {
              fetch('/diyvoice/delete-audio/', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({file_path: fileToDelete})
              })
              .then(res => res.json())
              .then(data => {
                  if (data.status === 'success') {
                      console.log('ä¸­æ–­çš„éŸ³é¢‘æ–‡ä»¶å·²åˆ é™¤:', fileToDelete);
                  } else {
                      console.error('åˆ é™¤ä¸­æ–­éŸ³é¢‘å¤±è´¥:', data.message);
                  }
              })
              .catch(e => console.error('åˆ é™¤è¯·æ±‚é”™è¯¯:', e));
          }
          
          console.log("å·²åœæ­¢æ’­æ”¾");
        }
        
        if (!isRecording) {
          console.log("ğŸ¤ å¼€å§‹å½•éŸ³...");
          mediaRecorder.start();
          recordStartTime = Date.now();
          isRecording = true;
        }
        silenceStartTime = null;
      }

      if (isRecording) {
        if (volume <= VOLUME_THRESHOLD) {
          if (!silenceStartTime) silenceStartTime = Date.now();
          else if (Date.now() - silenceStartTime >= SILENCE_TIMEOUT) {
            console.log("ğŸ›‘ é™éŸ³è¶…è¿‡ 2 ç§’ï¼Œåœæ­¢å½•éŸ³");
            mediaRecorder.stop();
            isRecording = false;
          }
        }

        if (Date.now() - recordStartTime >= MAX_RECORD_TIME) {
          console.log("â±ï¸ è¾¾åˆ°æœ€é•¿å½•éŸ³æ—¶é—´ï¼Œåœæ­¢å½•éŸ³");
          mediaRecorder.stop();
          isRecording = false;
        }
      }
    }

    startMonitoring();
  </script>
</body>
</html>
